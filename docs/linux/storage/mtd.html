<!DOCTYPE html>

<meta charset="utf-8">

<link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/6.0.0/normalize.min.css" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Lato|Source+Code+Pro:500" rel="stylesheet">
<link href="/static/css/main.css" rel="stylesheet">


<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.10.0/styles/atom-one-light.min.css" rel="stylesheet">


<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.10.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


<title>MTD</title>

<meta name="author" content="Clay McClure">
<meta name="description" content="Compendium of computing articles focused on embedded Linux, networking, and C, C++, and Python programming.">


<div class="document">
  <div class="documentwrapper">
    <div class="contentwrapper">
      <main class="content">
        <h1 id="MTD">MTD</h1>
<p>The Memory Technology Devices (MTD) subsystem provides a common interface to
many types of <a href="/hardware/storage/flash.html">raw flash</a> storage devices. It
includes facilities for partioning flash, erasing flash, and managing bad
blocks.</p>
<h2 id="Listing-devices-and-partitions">Listing devices and partitions</h2>
<p>The <code>mtdinfo</code> command, provided as part of the <a href="http://git.infradead.org/mtd-utils.git">mtd-utils</a> distribution,
displays all available MTD devices and partitions:</p>
<pre><code>$ mtdinfo
Count of MTD devices:           5
Present MTD devices:            mtd0, mtd1, mtd2, mtd3, mtd4
Sysfs interface supported:      yes
</code></pre>
<p>Given a device argument (or <code>--all</code>), <code>mtdinfo</code> prints detailed device
information:</p>
<pre><code>$ mtdinfo /dev/mtd0
mtd0
Name:                           NAND 128MiB 1,8V 8-bit
Type:                           nand
Eraseblock size:                16384 bytes, 16.0 KiB
Amount of eraseblocks:          8192 (134217728 bytes, 128.0 MiB)
Minimum input/output unit size: 512 bytes
Sub-page size:                  256 bytes
OOB size:                       16 bytes
Character device major/minor:   90:0
Bad blocks are allowed:         true
Device is writable:             true
</code></pre>
<p>Like many such userspace tools, <code>mtdinfo</code> is a thin wrapper around the MTD
SysFS interface in <code>/sys/class/mtd</code>.</p>
<h2 id="Devices">Devices</h2>
<p>MTD provides a pair of character devices for each flash device and partition:</p>
<ul>
<li><code>/dev/mtdX</code> (read-write)</li>
<li><code>/dev/mtdXro</code> (read-only)</li>
</ul>
<p>Most <a href="http://git.infradead.org/mtd-utils.git">mtd-utils</a> commands take a <code>/dev/mtdX</code> device node as an argument.</p>
<p>You can read/write directly from/to <code>/dev/mtdX</code> devices, but there are
complications:</p>
<ul>
<li>reads can be any size, but writes must be a multiple of the device's
minimum write size (as reported by <code>/sys/class/mtd/mtdX/writesize</code>)</li>
<li>blocks must be erased before they can be written</li>
<li>on NAND devices, reading from or writing to a bad block may produce
unexpected results</li>
</ul>
<h2 id="Partitions">Partitions</h2>
<p>MTD allows flash devices to be carved into partitions. Several on-flash
partition table formats are supported, as well as partitions defined on the
kernel command line or in the device tree.</p>
<h2 id="Utilities">Utilities</h2>
<p>The <code>flash_erase</code> utility from the <a href="http://git.infradead.org/mtd-utils.git">mtd-utils</a> distribution erases all bytes
(data and out-of-band) of a device, partition, or subset of blocks:</p>
<pre><code>$ flash_erase /dev/mtd0 0 0
Erasing 16 Kibyte @ 7ffc000 -- 100 % complete 
</code></pre>
<p>Reading an erased flash returns all-ones:</p>
<pre><code>$ dd if=/dev/mtd0 bs=512 count=1 | hd
00000000  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|
*
00000200
</code></pre>
<p>The <code>mtdpart</code> utility adds and deletes MTD partitions (but does not update
on-flash partition tables).</p>
<h3 id="NAND-simulator">NAND simulator</h3>
<p>MTD includes a NAND simulator module (<code>nandsim</code>) that attaches a virtual MTD
device:</p>
<pre><code>$ modprobe nandsim

$ mtdinfo -a
Count of MTD devices:           1
Present MTD devices:            mtd0
Sysfs interface supported:      yes

mtd0
Name:                           NAND simulator partition 0
Type:                           nand
Eraseblock size:                16384 bytes, 16.0 KiB
Amount of eraseblocks:          8192 (134217728 bytes, 128.0 MiB)
Minimum input/output unit size: 512 bytes
Sub-page size:                  256 bytes
OOB size:                       16 bytes
Character device major/minor:   90:0
Bad blocks are allowed:         true
Device is writable:             true
</code></pre>
<h2 id="Programming-Interfaces">Programming Interfaces</h2>
<h3 id="ioctl"><code>ioctl</code> ABI</h3>
<p>Behind the scenes, the <a href="http://git.infradead.org/mtd-utils.git">mtd-utils</a> commands interact with the MTD subsystem
via an <code>ioctl</code> interface:</p>
<pre><code class="language-c">/* Get basic MTD characteristics info (better to use sysfs) */
#define MEMGETINFO              _IOR('M', 1, struct mtd_info_user)

/* Erase segment of MTD */
#define MEMERASE                _IOW('M', 2, struct erase_info_user)

/* Write out-of-band data from MTD */
#define MEMWRITEOOB             _IOWR('M', 3, struct mtd_oob_buf)

/* Read out-of-band data from MTD */
#define MEMREADOOB              _IOWR('M', 4, struct mtd_oob_buf)

/* Lock a chip (for MTD that supports it) */
#define MEMLOCK                 _IOW('M', 5, struct erase_info_user)

/* Unlock a chip (for MTD that supports it) */
#define MEMUNLOCK               _IOW('M', 6, struct erase_info_user)

/* Check if chip is locked (for MTD that supports it) */
#define MEMISLOCKED             _IOR('M', 23, struct erase_info_user)

/* Check if an eraseblock is bad */
#define MEMGETBADBLOCK          _IOW('M', 11, __kernel_loff_t)

/* Mark an eraseblock as bad */
#define MEMSETBADBLOCK          _IOW('M', 12, __kernel_loff_t)

/*
 * Most generic write interface; can write in-band and/or out-of-band in various
 * modes (see &quot;struct mtd_write_req&quot;)
 */
#define MEMWRITE                _IOWR('M', 24, struct mtd_write_req)
</code></pre>
<h3 id="libmtd">libmtd</h3>
<p>The <a href="http://git.infradead.org/mtd-utils.git">mtd-utils</a> source builds a static library (libmtd.a) that wraps the MTD
ioctls in a tidy API, e.g., <code>mtd_mark_bad()</code>:</p>
<pre><code class="language-c">/**
 * mtd_mark_bad - mark an eraseblock as bad.
 * @mtd: MTD device description object
 * @fd: MTD device node file descriptor
 * @eb: eraseblock to mark as bad
 *
 * This function marks eraseblock @eb as bad. Returns %0 in case of success and
 * %-1 in case of failure.
 */
int mtd_mark_bad(const struct mtd_dev_info *mtd, int fd, int eb);
</code></pre>
<p>Sadly, libmtd.a is not included in the <a href="http://git.infradead.org/mtd-utils.git">mtd-utils</a> binary distribution.</p>
<h3 id="Kernel-API">Kernel API</h3>
<p>Higher layer kernel subsystems (flash filesytems, <a href="ubi.html">UBI</a>) interact with raw
flash via the MTD API defined in <a href="http://elixir.free-electrons.com/source/include/linux/mtd/mtd.h">include/linux/mtd/mtd.h</a>, including:</p>
<pre><code class="language-c">int mtd_read(struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf);
int mtd_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf);
int mtd_erase(struct mtd_info *mtd, struct erase_info *instr);
int mtd_read_oob(struct mtd_info *mtd, loff_t from, struct mtd_oob_ops *ops);
int mtd_write_oob(struct mtd_info *mtd, loff_t to, struct mtd_oob_ops *ops);
</code></pre>
<p>Device drivers register MTD devices with the MTD core via
<a href="http://elixir.free-electrons.com/ident?v=4.10&amp;i=mtd_device_register"><code>mtd_device_register()</code></a>.</p>

      </main>
      <footer>
        Copyright Â© 2017 <a href="http://claymation.me">Clay McClure</a>. Made with <a href="https://claymation.github.io/void/">void</a>.
      </footer>
    </div>
  </div>

  <div class="sidebar">
    <div class="sidebarwrapper">
      <a href="/"><img src="/static/images/tuxdemon.png" width=160 height=160 alt="Tux (the Linux penguin) with daemon horns"></a>
      <section class="toc">
        <h2>Table of Contents</h2>
        
        
          
            <ul><li>
          
          <a href="#MTD">MTD</a>
          
          
        
          
            <ul><li>
          
          <a href="#Listing-devices-and-partitions">Listing devices and partitions</a>
          
          
        
          
            </li><li>
          
          <a href="#Devices">Devices</a>
          
          
        
          
            </li><li>
          
          <a href="#Partitions">Partitions</a>
          
          
        
          
            </li><li>
          
          <a href="#Utilities">Utilities</a>
          
          
        
          
            <ul><li>
          
          <a href="#NAND-simulator">NAND simulator</a>
          
          
        
          
            </li></ul><li>
          
          <a href="#Programming-Interfaces">Programming Interfaces</a>
          
          
        
          
            <ul><li>
          
          <a href="#ioctl">ioctl</a>
          
          
        
          
            </li><li>
          
          <a href="#libmtd">libmtd</a>
          
          
        
          
            </li><li>
          
          <a href="#Kernel-API">Kernel API</a>
          
          
        
        
          </li></ul>
        
          </li></ul>
        
          </li></ul>
        
      </section>
    </div>
  </div>
</div>
